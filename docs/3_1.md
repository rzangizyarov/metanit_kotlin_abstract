# 3.1 Функции и их параметры

Функция — это фрагмент кода, который выполняет определенную задачу и может использоваться повторно. 

В Kotlin функция объявляется с помощью ключевого слова `fun`, после которого идет название функции. Затем после названия в скобках указывается список параметров.
Если функция возвращает какое-либо значение, то после списка параметров через запятую можно указать тип возвращаемого значения. И далее в фигурных скобках идет тело функции.

```kotlin
fun имя_функции (параметры) : возвращаемый_тип {
    выполняемые инструкции
}
```

Параметры необязательны. Если вы не хотите, чтобы функция возвращала значение, исключите возвращаемый тип из объявления функции или укажите
возвращаемый тип `Unit`. Объявление возвращаемого типа `Unit` означает, что функция не возвращает значения.

Например, определим и вызовем функцию, которая просто выводит некоторую
строку на консоль:

```kotlin
fun main() {
    hello()     // вызов функции hello
    hello()     // вызов функции hello
    hello()     // вызов функции hello
}

fun hello() {    // определение функции верхнего уровня hello
    println("Hello")
}
```

```commandline
Hello
Hello
Hello

```

Функции можно определять в файле вне других функций или классов, сами по себе, как например, определяется функция `main`. Такие функции еще называют функциями верхнего уровня (top-level functions). 
Здесь кроме главной функции `main` также определена функция `hello`, которая не принимает никаких параметров и ничего не возвращает. Она просто
выводит строку на консоль.

Функция `hello` (и любая другая определенная функция, кроме `main`) сама по себе не выполняется. Чтобы ее выполнить, ее надо вызвать. Для вызова функции указывается ее имя (в данном случае "hello"), после которого идут пустые скобки.

Таким образом, если необходимо в разных частях программы выполнить одни и те же действия, то можно эти действия вынести в функцию, и затем вызывать эту функцию. 

## Модификатор видимости

Не все функции должны быть видимы (доступны) для других функций. Например, некоторые функции могут оперировать данными, которые не должны быть доступны за пределами конкретного файла. При необходимости объявление функции может начинаться с модификатора видимости. Он определяет, какие другие функции смогут «видеть», а следовательно использовать, данную функцию. 

По умолчанию функция имеет глобальную видимость (`public`), то есть является открытой, — это означает, что она может использоваться всеми остальными функциями (даже теми, которые объявлены в других файлах проекта). Другими словами, если вы не указали модификатор, считается, что используется модификатор `public`

```kotlin
private fun hello() {   
    println("Hello")
}
```

## Предача параметров

Через параметры функция может получать некоторые значения извне. Параметры указываются после имени функции в скобках через запятую в формате `имя_параметра : тип_параметра`. Например, определим функцию, которая просто выводит сообшение на консоль: 

```kotlin
fun main() {
    showMessage("Hello Kotlin")
    showMessage("Привет Kotlin")
    showMessage("Salut Kotlin")
}

fun showMessage(message: String) {
    println(message)
}
```

```commandline
Hello Kotlin
Привет Kotlin
Salut Kotlin
```

Функция `showMessage()` принимает один параметр типа `String`. Поэтому
при вызове функции в скобках необходимо передать значение для этого
параметра: `showMessage("Hello Kotlin")`. Причем это значение должно
представлять тип `String`, то есть строку. Значения, которые передаются
параметрам функции, еще назвают аргументами.

Другой пример - функция, которая выводит данные о пользователе на
консоль:

```kotlin
fun main() {
    displayUser("Tom", 23)
    displayUser("Alice", 19)
    displayUser("Kate", 25)
}

fun displayUser(name: String, age: Int) {
    println("Name: $name   Age: $age")
}
```

```commandline
Name: Tom   Age: 23
Name: Alice   Age: 19
Name: Kate   Age: 25
```

Функция `displayUser()` в данном примере принимает два параметра - `name` и `age`. При вызове функции в скобках ей передаются значения для этих параметров. При этом значения передаются параметрам по позиции и должны соответствовать параметрам по типу. Так как вначале идет параметр типа `String`, а потом параметр типа `Int`, то при вызове функции в скобках вначале передается строка, а потом число.

## Аргументы по умолчанию

В примере выше при вызове функций `showMessage` и `displayUser` мы обязательно должны предоставить для каждого из параметра какое-то определенное значение, которое соответствует типу параметра. Мы не
можем, к примеру, вызвать функцию `displayUser`, не передав ей аргументы для параметров, это будет ошибка:

```kotlin
displayUser()
```

```commandline
Line_3.jupyter.kts (1:12 - 14) No value passed for parameter 'name'
Line_3.jupyter.kts (1:12 - 14) No value passed for parameter 'age'
```

Однако мы можем определить какие-то параметры функции как необязательные и установить для них значения по умолчанию:

```kotlin
fun displayUser(name: String, age: Int = 18, position: String="unemployed") {
    println("Name: $name   Age: $age  Position: $position")
}

fun main() {
    displayUser("Tom", 23, "Manager")
    displayUser("Alice", 21)
    displayUser("Kate")
}
```

```commandline
Name: Tom   Age: 23  Position: Manager
Name: Alice   Age: 21  Position: unemployed
Name: Kate   Age: 18  Position: unemployed
```

В данном случае функция `displayUser` имеет три параметра для передачи имени, возраста и должности. Для первого параметр `name` значение по умолчанию не установлено, поэтому для него значение по-прежнему
обязательно передавать значение. Два последующих - `age` и `position` являются необязательными, и для них установлено значение по умолчанию. Если для этих параметров не передаются значения, тогда параметры используют значения по умолчанию. Поэтому для этих параметров в принципе нам необязательно передавать аргументы. Но если для какого-то параметра определено значение по умолчанию, то для всех последующих параметров тоже должно быть установлено значение по умолчанию.

## Именованные аргументы

По умолчанию значения передаются параметрам по позиции слева-направо: первое значение - первому параметру, второе значение - второму параметру и так далее. Однако, используя именованные аргументы, мы можем переопределить порядок их передачи параметрам:

```kotlin
fun main() {
    displayUser("Tom", position = "Manager", age = 28)
    displayUser(age = 21, name = "Alice")
    displayUser("Kate", position="Middle Developer")
}
```

При вызове функции в скобках мы можем указать название параметра и с помощью знака равно передать ему нужное значение.

При этом, как видно из последнего случае, необязательно все аргументы передавать по имени. Часть аргументов могут передаваться параметрам по позиции. Но если какой-то аргумент передан по имени, то остальные аргументы после него также должны передаваться по имени соответствующих параметров.

Также если до обязательного параметра функции идут необязательные параметры, то для обязательного параметра значение передается по имени:

```kotlin
fun displayUser(age: Int = 18, name: String) {
    println("Name: $name   Age: $age")
}

fun main() {
    displayUser(name = "Tom", age = 28)
    displayUser(name = "Kate")
}
```

```commandline
Name: Tom   Age: 28
Name: Kate   Age: 18
```

## Стратегия вычисления в Java. Передача по значению.

*Стратегия вычисления* (англ. *evaluation strategy*) — правила семантики языка программирования, определяющие, когда следует вычислять аргументы функции (метода, операции, отношения), и какие значения следует передавать.

Распространённые стратегии вычисления:

- **Передача по значению** (**passing by value**) - аргумент вычисляется и связывается с формальным параметром функции (значение копируется в новую область памяти). При этом, если язык разрешает функциям присваивать значения своим параметрам\* , то изменения будут касаться лишь этих локальных копий, но видимые в месте вызова функции значения останутся неизменными по возвращении ([источник](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F#%D0%92%D1%8B%D0%B7%D0%BE%D0%B2_%D0%BF%D0%BE_%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8E_(call-by-value))).
    
    > \* это не про Kotlin, так как по умолчанию все параметры функции равносильны `val`-переменным

    Методу передаётся значение переменной, и когда метод вызывается, то в области действия метода создается новая копия переменной. Любые изменения, внесенные в эту переменную в методе, не влияют на исходную переменную.

- **Передача по ссылке** (**passing by value**): функция неявно получает ссылку на **переменную**\*, использованную в качестве аргумента, вместо копии её значения.

    > \* не на объект внутри переменной и не на ссылку на объект, содержащуюся внутри переменной, а ссылку на саму переменную

    При вызове метода в метод передается ссылка (адрес памяти) на исходную переменную. Любые изменения, внесенные в переменную в методе, также влияют на исходную переменную.

Java поддерживает **только** передачу по значению. При передаче в функцию объекта (не примитивного типа) в качестве значения передаётся копия ссылки на объект в памяти.

По умолчанию все параметры функции равносильны `val`-переменным, поэтому их значение нельзя изменить. Например, в случае следующей функции при компиляции мы получим ошибку:

```kotlin
fun double(n: Int) {
    n = n * 2    // !Ошибка - значение параметра нельзя изменить.
    println("Значение в функции double: $n")
}

double(25)
```

```commandline
Line_7.jupyter.kts (2:5 - 6) Val cannot be reassigned
```

Почему указания `var` или `val` не разрешены в параметре функции? Прежде всего, изменение параметров функции в теле функции — это нехороший стиль. В Java имеется возможность изменить параметр функции в теле функции. Но что это значит? Так как мы работаем с переменной-копией фактически мы просто в изменим ссылку, находящуюся в локальной переменной на новую, не изменяя исходную внешнюю перемнную.

Люди иногда склонны думать, что передача аргумента равна передаче ссылки на **переменную** целиком, что не поддерживается языком (это требует больших затрат во время выполнения). Вместо этого поддерживается только передача копии ссылка на объект, находящийся внутри переменной.

Еще одним источником путаницы являются первичные конструкторы: `val` или `var` в объявлении конструктора означают нечто иное, чем то же самое, если объявляется функция (а именно, она создает свойство). Кроме того, мы все знаем, что изменение параметров — это нехороший стиль, поэтому писать `val` или `var` перед параметром в функции, блоке `catch` в цикле `for` больше нельзя.

Однако если параметр представляет какой-то сложный объект, то можно изменять отдельные значения в этом объекте. Например, возьмем функцию, которая в качестве параметра принимает массив:

```kotlin
fun double(numbers: IntArray) {
    numbers[0] = numbers[0] * 2
    println("Значение в функции double: ${numbers[0]}")
}

fun main() {
    var nums = intArrayOf(4, 5, 6)
    double(nums)
    println("Значение в функции main: ${nums[0]}")
}
```

```commandline
Значение в функции double: 8
Значение в функции main: 8
```

Здесь функция `double` принимает числовой массив и увеличивает значение
его первого элемента в два раза. Так как массивы представляют собой изменяемые коллекции, изменение элемента массива внутри функции влияет на изначальный объект.


## Получение значений из функции

Если вы хотите получить значение (объект) из функции, сначала его необходимо
объявить и проинициализировать. Например, вот как объявляется функция с именем `max`, которая возвращает значение `Int`:


```kotlin
fun max(a: Int, b: Int): Int {         // Int сообщает компилятору, что функция возвращает значение Int
    val maxValue = if (a > b) a else b
    return maxValue                    // Чтобы вернуть значение, используйте ключевое слово return, за которым следует возвращаемое значение.
}

fun main() {
    val maxValue: Int
    maxValue = max(8, 5)
    print(maxValue)
}
```

```commandline
8
```

## Функции из единственного выражения

Если у вас имеется функция, тело которой состоит из одного выражения, код можно упростить, удалив фигурные скобки и команду `return` из объявления функции

```kotlin
fun max(a: Int, b: Int): Int {
    val maxValue = if (a > b) a else b
    return maxValue
}
```

```kotlinы
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

А поскольку компилятор может определить возвращаемый тип функции по выражению `if`, код можно дополнительно сократить,
убрав из него `: Int`

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b // Компилятор знает, что a и b имеют тип Int, и поэтому может определить возвращаемый тип функции по выражению
```

## Области видимости функций

Как уже упоминалось в этой главе, локальные переменные используются внутри тела функции. Они объявляются внутри функции и видны только внутри этой функции. При попытке использовать переменную, определенную внутри другой функции, компилятор выдает сообщение об ошибке. Обращения к глобальным переменным работают.

Для вложенных функций правило **LEGB** (**L**ocal **E**nclosure **G**lobal **B**uiltins) из Python работает.

```kotlin
fun main() {
    var x = 6
    myFunction()
}

fun myFunction() {
    var y = x + 3 // Код не компилируется, потому что myFunction не видит переменную x, объявленную в main.
}
```

```commandline
Line_13.jupyter.kts (2:9 - 10) Variable 'x' is never used
Line_13.jupyter.kts (7:9 - 10) Variable 'y' is never used
Line_13.jupyter.kts (7:13 - 14) Unresolved reference: x
```

Любые локальные переменные должны инициализироваться перед использованием. Например, если вы используете переменную для возвращения значения из функции, эту переменную
необходимо инициализировать; в противном случае компилятор выдаст сообщение об ошибке

```kotlin
fun myFunction(): String {
    var message: String
    return message        // Необходимо инициализировать переменную, если вы хотите использовать 
}                         // ее для возвращения значения функции, иначе этот код компилироваться не будет.
```

```commandline
Line_68.jupyter.kts (3:12 - 19) Variable 'message' must be initialized
```

Параметры функций практически не отличаются от локальных переменных; они тоже существуют только в контексте функции. При этом они всегда инициализируются, поэтому вы никогда
не получите ошибку компилятора с указанием на то, что переменная параметра не была инициализирована. Дело в том, что компилятор выдаст сообщение об ошибке, если вы попытаетесь
вызвать функцию без необходимых аргументов: компилятор гарантирует, что функции всегда
будут вызываться с аргументами, соответствующими параметрам функции, и эти аргументы
будут автоматически присвоены параметрам. Помните, что переменным параметров нельзя
присвоить новые значения. За кулисами переменные параметров создаются как локальные
переменные `val`, которые не могут повторно использоваться для других значений. Например,
следующий код не будет компилироваться, потому что он пытается присвоить новое значение
переменной параметра функции:

```kotlin
fun myFunction(message: String){
    message = "Hi!" // Переменные параметров рассматриваются как локальные переменные, созданные с ключевым
}                   // словом val, поэтому они не могут повторно использоваться для других значений.
```


## Резюме

```kotlin
// Функция — это фрагмент кода, который выполняет
// определенную задачу и может использоваться повторно.

// Функция верхнего уровня (top-level).
// По умолчанию функции имеют модификатор видимости public.
// private-функция не может быть использована за пределами
// данного файла.
private fun hello() {
    println("hello")
}

// Функция с аргументами по умолчанию
fun displayUser(name: String, age: Int = 18, position: String = "unemployed") {
    println("Name: $name\tAge: $age\tPosition: $position")
}

// Изменение параметра
fun doubler(n: Int) { // параметры функции равносильны val переменным
//    n = n * 2       // !Ошибка - значение val переменной нельзя изменить.
    println("Значение в функции doubler: ${n * 2}")
}

// Если в качестве параметра передана ссылка на сложный объект, то
// можно изменять его состояние.
fun arrayDoubler(numbers: IntArray): IntArray {
    for (i in numbers.indices) {
        numbers[i] *= 2
    }
    return numbers // Возврат значения, если надо
}

// Если функция состоит из одного выражения, то использовать запись:
fun <T: Comparable<T>> max(a: T, b: T): T = if (a > b) a else b

// Также сработает. Компилятор выведет тип функции по типу возвращаемого
//fun <T: Comparable<T>> max(a: T, b: T) = if (a > b) a else b

// Области видимости функций
// Как уже упоминалось, локальные переменные используются внутри тела функции.
// Они объявляются внутри функции и видны только внутри этой функции.
// Для вложенных функций работает правило LEGB (Local Enclosure Global Builtins)

fun main() {
    hello()

    displayUser("Tom", 23, "Manager")
    displayUser(name = "Alice", age = 21) // передача параметра по имени

    val a = intArrayOf(1, 2, 3)
    arrayDoubler(a)
    println(a.contentToString())  // (2, 4, 6)

    val maxValue = max('a', 'z')
    println(maxValue)
}

```

